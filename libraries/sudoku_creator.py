from libraries.sudoku_solver import SudokuSolver
from libraries.puzzle import Puzzle
from random import choice, randint
from copy import copy
class SudokuCreator(SudokuSolver):
    
    @staticmethod
    def random_solve(puzzle:list) -> list:
        """_Solves a given sudoku puzzle in a random order. You can put the same puzzle in multiple times and get different answers if it has multiple solutions._

        Args:
            puzzle (list): _The unsolved puzzle._

        Returns:
            list: _The solved puzzle._
        """
        p = Puzzle(copy(puzzle))
        if p.solved:
            return p.puzzle
        p.random_init()
        return __class__.unwrapped_solve(p)
    
    @staticmethod
    def reverse_solve(puzzle:list) -> list:
        """_Solves a given sudoku puzzle in reverse order. Useful for cross-checking with the normal solver to check for multiple solutions._

        Args:
            puzzle (list): _The unsolved puzzle._

        Returns:
            list: _The solved puzzle._
        """
        p = Puzzle(copy(puzzle))
        if p.solved:
            return p.puzzle
        p.reverse_init()
        return __class__.unwrapped_solve(p)
    
    @staticmethod
    def blank_puzzle() -> list:
        """_Creates a 81 list filled with all zeros._

        Returns:
            list: _List filled with all zeros._
        """
        return [0] * 81
        
    @staticmethod    
    def create_solved_puzzle() -> list:
        """_Solved a blank puzzle with the random solver. This will create a random, solved puzzle each time it is run._

        Returns:
            list: _The solved puzzle._
        """
        return __class__.random_solve(__class__.blank_puzzle())

    
    @staticmethod
    def single_solution(puzzle:list) -> bool:
        """_Checks if a puzzle only has one solution by solving it in both standard and reverse order._

        Args:
            puzzle (list): _The puzzle you want to check._

        Returns:
            bool: _Returns true if the puzzle only has one solution. Otherwise, it will return false._
        """
        return True if (__class__.solve(puzzle) == __class__.reverse_solve(puzzle)) else False

    
    @staticmethod
    def create_unsolved(puzzle:list = None, min_hints:int = randint(20,30), filled:list = None) -> list:
        """_Randomly removes hints from a puzzle until it reaches the desired number of hints or there are multiple solutions._

        Args:
            puzzle (list, optional): _The filled puzzle. Do not need to use unless you want to remove hints from a specific puzzle._ Defaults to None.
            min_hints (int, optional): _The minimum number of hints you want your final puzzle to have. There needs to be at least 17 hints for the puzzle to be valid._ Defaults to randint(20,30).
            filled (list, optional): _A list of all the filled positions in the puzzle. Will be generated by the method if not given._ Defaults to None.

        Returns:
            list: _The final unsolved puzzle._
        """
        if puzzle == None:
            puzzle = __class__.create_solved_puzzle()
        
        if filled == None:
            filled = []
            for i, _ in ((i, item) for i, item in enumerate(puzzle) if item):
                filled.append(i)
                    
        if min_hints < len(filled):
            try:
                z = choice(filled)
            except IndexError:
                return puzzle
            y = copy(puzzle[z])
            puzzle[z] = 0
            filled.remove(z)
            if not __class__.single_solution(puzzle):
                puzzle[z] = y
            
            return __class__.create_unsolved(puzzle, min_hints, filled)
            
        else:
            return puzzle

